# ETF Challenger v1.1.0 功能设计文档

## 概述

v1.1.0版本将引入**智能推荐系统**，将ETF Challenger从数据分析工具升级为智能投资助手。核心目标是通过用户画像、智能推荐、组合管理和风险预警，为用户提供个性化的投资决策支持。

---

## 1. 用户画像系统

### 1.1 风险评估问卷

**目标**: 科学评估用户风险承受能力

**问卷设计** (8-10题):
1. 年龄段: <30 / 30-40 / 40-50 / >50
2. 投资经验: 新手 / 1-3年 / 3-5年 / >5年
3. 投资目标: 稳定收益 / 长期增值 / 短期收益
4. 亏损承受: 5% / 10% / 20% / >20%
5. 投资期限: <1年 / 1-3年 / 3-5年 / >5年
6. 收入来源: 工资 / 投资 / 混合
7. 紧急备用金: 充足 / 一般 / 不足
8. 市场下跌反应: 加仓 / 观望 / 减仓 / 清仓

**评分规则**:
```python
total_score = sum(question_scores)
if total_score < 20:
    risk_level = "保守型"
elif total_score < 40:
    risk_level = "稳健型"
else:
    risk_level = "激进型"
```

**命令实现**:
```bash
etf profile init
# 交互式问卷，逐题回答
# 自动计算风险等级
# 保存到 ~/.etf_challenger/config/user_profile.json
```

### 1.2 用户画像数据结构

```json
{
  "user_profile": {
    "risk_tolerance": "稳健型",
    "risk_score": 35,
    "investment_goal": "长期增值",
    "time_horizon": "3-5年",
    "max_loss_tolerance": 15.0,
    "preferences": {
      "industries": ["科技", "医药", "消费"],
      "avoid_industries": ["煤炭", "钢铁"],
      "min_scale": 10.0,
      "max_fee": 0.6,
      "min_liquidity_score": 80.0
    },
    "created_at": "2026-02-01",
    "updated_at": "2026-02-01"
  }
}
```

### 1.3 画像管理命令

```bash
# 初始化（首次使用）
etf profile init

# 查看当前画像
etf profile show

# 更新偏好（重新问卷）
etf profile update

# 修改特定配置
etf profile set --industry 科技 新能源
etf profile set --max-loss 20
```

---

## 2. 智能推荐引擎

### 2.1 推荐算法设计

#### 评分维度

| 维度 | 权重 | 说明 |
|------|------|------|
| 收益潜力 | 30% | 基于历史收益和技术指标 |
| 风险匹配度 | 25% | 波动率与用户承受能力匹配 |
| 流动性 | 20% | 规模和成交量评分 |
| 费率优势 | 15% | 管理费率越低越好 |
| 行业偏好 | 10% | 是否符合用户偏好行业 |

#### 保守型策略权重调整
```python
conservative_weights = {
    "收益潜力": 0.20,
    "风险匹配度": 0.35,  # 提高
    "流动性": 0.25,      # 提高
    "费率优势": 0.15,
    "行业偏好": 0.05
}
```

#### 激进型策略权重调整
```python
aggressive_weights = {
    "收益潜力": 0.45,  # 提高
    "风险匹配度": 0.15,  # 降低
    "流动性": 0.15,
    "费率优势": 0.10,
    "行业偏好": 0.15
}
```

### 2.2 评分计算公式

```python
def calculate_recommendation_score(etf, user_profile, strategy="balanced"):
    # 1. 收益潜力得分 (0-100)
    return_score = calculate_return_score(etf.annual_return, etf.sharpe_ratio)
    
    # 2. 风险匹配度 (0-100)
    risk_score = calculate_risk_match(etf.volatility, user_profile.max_loss_tolerance)
    
    # 3. 流动性得分 (0-100)
    liquidity_score = etf.liquidity_score
    
    # 4. 费率得分 (0-100)
    fee_score = (0.6 - etf.fee_rate) / 0.6 * 100
    
    # 5. 行业偏好得分 (0-100)
    industry_score = 100 if etf.industry in user_profile.industries else 50
    
    # 加权求和
    weights = get_strategy_weights(strategy)
    total_score = (
        return_score * weights['收益潜力'] +
        risk_score * weights['风险匹配度'] +
        liquidity_score * weights['流动性'] +
        fee_score * weights['费率优势'] +
        industry_score * weights['行业偏好']
    )
    
    return total_score
```

### 2.3 推荐理由生成

```python
def generate_recommendation_reason(etf, score_breakdown):
    reasons = []
    
    if score_breakdown['return_score'] >= 80:
        reasons.append(f"过去一年收益率达{etf.annual_return:.1f}%，表现优异")
    
    if score_breakdown['risk_score'] >= 80:
        reasons.append(f"波动率{etf.volatility:.1f}%，风险可控，符合您的风险偏好")
    
    if score_breakdown['liquidity_score'] >= 90:
        reasons.append(f"规模{etf.scale:.0f}亿份，流动性优秀，适合大额交易")
    
    if etf.fee_rate <= 0.5:
        reasons.append(f"管理费率仅{etf.fee_rate}%，费用优势明显")
    
    if etf.industry in user_profile.industries:
        reasons.append(f"属于您关注的{etf.industry}行业")
    
    return reasons
```

### 2.4 推荐命令实现

```bash
# 基础推荐（使用默认策略）
etf recommend

# 指定策略
etf recommend --strategy conservative  # 保守型
etf recommend --strategy balanced      # 稳健型
etf recommend --strategy aggressive    # 激进型

# 特定行业推荐
etf recommend --industry 科技
etf recommend --industry 医药 消费

# 指定数量
etf recommend --top 20

# 排除已持有
etf recommend --exclude-portfolio

# 输出格式
etf recommend --format table  # 默认
etf recommend --format json   # JSON输出
```

**输出示例**:
```
智能推荐 (基于您的稳健型画像)

┌──────┬──────────┬────────┬──────┬──────┬──────────────────────┐
│ 排名 │ 代码     │ 名称   │ 评分 │ 风险 │ 推荐理由             │
├──────┼──────────┼────────┼──────┼──────┼──────────────────────┤
│  1   │ 510300   │ 沪深300│ 92.5 │ 中   │ • 规模910亿，流动性优│
│      │          │ ETF    │      │      │ • 费率0.5%，成本低   │
│      │          │        │      │      │ • 波动率15%，风险适中│
└──────┴──────────┴────────┴──────┴──────┴──────────────────────┘

匹配度说明:
✓ 已根据您的风险偏好筛选
✓ 已排除您不关注的行业
✓ 流动性评分均 >= 80
```

---

## 3. 投资组合管理

### 3.1 组合数据结构

```json
{
  "portfolio": {
    "name": "我的稳健组合",
    "created_at": "2026-02-01",
    "target_allocation": {
      "宽基指数": 50,
      "医疗医药": 20,
      "科技创新": 15,
      "港股海外": 10,
      "现金": 5
    },
    "positions": [
      {
        "etf_code": "510300",
        "etf_name": "沪深300ETF",
        "shares": 1000,
        "cost_basis": 4.500,
        "buy_date": "2026-01-15",
        "stop_loss": 4.050,
        "take_profit": 5.400
      }
    ],
    "total_cost": 45000.0,
    "rebalance_threshold": 5.0
  }
}
```

### 3.2 组合分析功能

#### 3.2.1 风险指标计算

```python
class PortfolioAnalyzer:
    def calculate_portfolio_volatility(self, positions, correlation_matrix):
        """计算组合波动率（考虑相关性）"""
        weights = [p.value / total_value for p in positions]
        volatilities = [p.volatility for p in positions]
        
        # 组合方差 = w'Σw
        portfolio_variance = 0
        for i in range(n):
            for j in range(n):
                portfolio_variance += (
                    weights[i] * weights[j] * 
                    volatilities[i] * volatilities[j] * 
                    correlation_matrix[i][j]
                )
        
        return sqrt(portfolio_variance)
    
    def calculate_var(self, positions, confidence=0.95, days=1):
        """计算VaR (Value at Risk)"""
        portfolio_value = sum(p.current_value for p in positions)
        portfolio_volatility = self.calculate_portfolio_volatility(positions)
        
        # 正态分布假设
        z_score = 1.65  # 95%置信度
        var = portfolio_value * portfolio_volatility * z_score * sqrt(days)
        return var
```

#### 3.2.2 相关性分析

```python
def calculate_correlation_matrix(etf_codes, days=90):
    """计算ETF间相关系数矩阵"""
    # 获取所有ETF的历史收益率
    returns = {}
    for code in etf_codes:
        df = get_historical_data(code, days)
        returns[code] = df['日收益率'].values
    
    # 计算相关系数矩阵
    correlation_matrix = pd.DataFrame(returns).corr()
    return correlation_matrix
```

### 3.3 再平衡策略

```python
def generate_rebalance_suggestions(portfolio):
    """生成再平衡建议"""
    current_allocation = calculate_current_allocation(portfolio)
    target_allocation = portfolio.target_allocation
    
    suggestions = []
    for category, target_pct in target_allocation.items():
        current_pct = current_allocation.get(category, 0)
        deviation = abs(current_pct - target_pct)
        
        if deviation > portfolio.rebalance_threshold:
            if current_pct > target_pct:
                action = "卖出"
                amount = (current_pct - target_pct) * portfolio_value / 100
            else:
                action = "买入"
                amount = (target_pct - current_pct) * portfolio_value / 100
            
            suggestions.append({
                "category": category,
                "action": action,
                "amount": amount,
                "reason": f"当前{current_pct:.1f}%，目标{target_pct:.1f}%"
            })
    
    return suggestions
```

### 3.4 组合管理命令

```bash
# 创建组合
etf portfolio create --name "我的稳健组合"

# 添加持仓
etf portfolio add 510300 --shares 1000 --price 4.5
etf portfolio add 512170 --amount 10000  # 按金额买入

# 设置止盈止损
etf portfolio set-stop 510300 --loss 4.05 --profit 5.4

# 查看组合
etf portfolio show
etf portfolio show --detail  # 详细信息

# 组合分析
etf portfolio analyze
# 输出: 组合收益率、波动率、夏普比率、VaR、相关性矩阵

# 再平衡建议
etf portfolio rebalance

# 持仓追踪
etf portfolio track
# 显示实时盈亏、止损触发等
```

---

## 4. 止盈止损管理

### 4.1 动态止损位计算

#### ATR止损法
```python
def calculate_atr_stop_loss(etf_code, multiplier=2.0):
    """基于ATR(平均真实波幅)计算止损位"""
    df = get_historical_data(etf_code, days=30)
    
    # 计算ATR
    df['TR'] = df[['最高', '最低', '昨收']].apply(
        lambda x: max(x['最高'] - x['最低'], 
                     abs(x['最高'] - x['昨收']),
                     abs(x['最低'] - x['昨收'])),
        axis=1
    )
    atr = df['TR'].rolling(14).mean().iloc[-1]
    
    current_price = df['收盘'].iloc[-1]
    stop_loss = current_price - (multiplier * atr)
    
    return stop_loss
```

#### 百分比止损法
```python
def calculate_percentage_stop_loss(cost_basis, loss_pct=10):
    """固定百分比止损"""
    return cost_basis * (1 - loss_pct / 100)
```

### 4.2 移动止盈策略

```python
def calculate_trailing_stop(position, trail_pct=5):
    """移动止盈止损"""
    current_price = get_current_price(position.etf_code)
    highest_price = position.highest_price  # 持仓期间最高价
    
    if current_price > highest_price:
        # 更新最高价
        highest_price = current_price
        position.highest_price = highest_price
    
    # 移动止损位 = 最高价 * (1 - 移动百分比)
    trailing_stop = highest_price * (1 - trail_pct / 100)
    
    return trailing_stop
```

---

## 5. 异常波动预警

### 5.1 预警规则引擎

```python
class AlertRule:
    def __init__(self, rule_type, threshold, action):
        self.rule_type = rule_type  # price/volume/premium
        self.threshold = threshold
        self.action = action  # email/console/log
    
    def check(self, etf_code):
        if self.rule_type == "price_change":
            return self._check_price_change(etf_code)
        elif self.rule_type == "volume_spike":
            return self._check_volume_spike(etf_code)
        # ...
```

### 5.2 预警类型

#### 5.2.1 价格异常
```python
def check_price_alert(etf_code, threshold=5.0):
    """检查价格异常波动"""
    quote = get_realtime_quote(etf_code)
    if abs(quote.change_pct) >= threshold:
        return Alert(
            type="price_change",
            etf_code=etf_code,
            message=f"{quote.name}涨跌幅达{quote.change_pct:+.2f}%",
            severity="high" if abs(quote.change_pct) >= 10 else "medium"
        )
```

#### 5.2.2 成交量异常
```python
def check_volume_alert(etf_code, multiplier=3.0):
    """检查成交量异常放大"""
    df = get_historical_data(etf_code, days=30)
    avg_volume = df['成交量'].mean()
    current_volume = df['成交量'].iloc[-1]
    
    if current_volume > avg_volume * multiplier:
        return Alert(
            type="volume_spike",
            message=f"成交量{current_volume/avg_volume:.1f}倍放大"
        )
```

### 5.3 预警命令

```bash
# 配置预警规则
etf alert setup
# 交互式配置: 预警类型、阈值、通知方式

# 查看所有预警规则
etf alert list

# 手动检查预警
etf alert check

# 启用/禁用预警
etf alert enable 价格异常
etf alert disable 成交量异常
```

---

## 6. 开发计划

### Phase 1: 用户画像 (2月1-7日)
- [ ] 设计问卷题目和评分规则
- [ ] 实现UserProfile数据模型
- [ ] 开发profile命令组
- [ ] 数据存储与读取

### Phase 2: 推荐引擎 (2月8-14日)
- [ ] 实现推荐评分算法
- [ ] 开发recommend命令
- [ ] 推荐理由生成逻辑
- [ ] 测试不同策略效果

### Phase 3: 组合管理 (2月15-21日)
- [ ] Portfolio数据模型
- [ ] portfolio命令组
- [ ] 风险分析算法
- [ ] 再平衡策略

### Phase 4: 预警系统 (2月22-28日)
- [ ] AlertRule引擎
- [ ] alert命令组
- [ ] 异常检测算法
- [ ] 通知机制

### Phase 5: 集成测试 (3月1-7日)
- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能优化
- [ ] 文档完善
- [ ] v1.1.0 发布

---

## 7. 技术栈

### 新增依赖
```toml
scikit-learn>=1.3.0    # 推荐算法、相关性计算
scipy>=1.11.0          # 统计分析
tabulate>=0.9.0        # 表格美化
questionary>=2.0.0     # 交互式问卷
```

### 项目结构
```
src/etf_challenger/
├── recommendation/          # 推荐系统
│   ├── profile.py          # 用户画像
│   ├── recommender.py      # 推荐引擎
│   └── scorer.py           # 评分算法
├── portfolio/              # 组合管理
│   ├── manager.py          # 组合管理器
│   ├── analyzer.py         # 组合分析
│   └── rebalancer.py       # 再平衡
├── alert/                  # 预警系统
│   ├── rule_engine.py      # 规则引擎
│   └── detectors.py        # 异常检测
└── storage/                # 数据存储
    └── user_data.py        # 用户数据管理
```
